# Access Management

Access Management is a flexible and extensible access control framework designed for Sui packages. This package offers a simple, intuitive API while allowing fine-grained, configurable permissions across multiple third-party packages without creating tight dependencies between them.

## Overview

The Access Management package provides a modular approach to managing permissions in a Sui-based environment. It introduces several core concepts:

- **PackageAdmin**: A unique administrator for each package (claimed during package publish) that controls the policies and rules for that package.
- **Policy**: Defines which entities are allowed to perform certain actions. A policy is created and managed by its associated PackageAdmin.
- **Rule**: Within a policy, rules bundle together permitted actions and, optionally, required conditions. Each rule is uniquely identified and scoped to a single policy.
- **ActionRequest**: A “hot-potato” object generated by a third-party function that encapsulates an action request. It can only be approved if the requester entity meets the policy’s conditions.
- **ConditionWitness**: A helper structure that carries condition configuration and metadata. It is used during the approval process to ensure that the correct conditions have been satisfied.

This design allows a single entity—or multiple entities—to be granted access to resources from different packages at any level of granularity guarded by configurable conditions.

## Features

- **Single PackageAdmin Per Package**: Only one PackageAdmin is allowed per package. It is claimed during package publish using a one-time witness (OTW) from the `access_init` module.
- **Flexible Policies and Rules**: Create policies that allow or deny access to entities based on dynamic rules. Each rule can be customized with a set of allowed actions and required conditions.
- **Reusable Conditions**: Conditions can be defined once and reused across multiple policies. Conditions may include additional configuration (`configs`) to support various use cases.
- **Action Requests & Approvals**: Third-party packages create action requests that can be conditionally approved by entities listed in a policy. PackageAdmins can also directly approve requests for their own package.

## Architecture

### PackageAdmin

- **Purpose**: Acts as the administrator for a package. It is responsible for creating policies and managing rules.
- **Claiming**: A `PackageAdmin` is claimed during package publish using a one-time witness from the `access_init` module.
- **Capabilities**: Can create policies, add/remove entities from policies, and approve action requests directly.

### Policy

- **Purpose**: Defines access permissions for a set of entities and groups allowed actions via rules.
- **Management**: Each policy is managed by a `PackageAdmin` and is tied to a single package.
- **Operations**:
  - Allows adding entities to a policy (i.e., allowlisting).
  - Enabling/disabling the policy.
  - Destroying a policy once empty.

### Rule

- **Purpose**: Bundles together one or more actions and their corresponding conditions.
- **Details**:
  - Each rule is uniquely identified.
  - All actions in a rule must belong to the same package as the policy.
  - Rules can optionally require one or more conditions to be approved.

### ActionRequest

- **Purpose**: Serves as the “hot-potato” for requesting access to an action. An `ActionRequest` is generated by a third-party function and can only be consumed once the entity’s permissions have been verified.
- **Contents**:
  - Contains the requested action.
  - A dynamic context (e.g., resource IDs, type names).
  - A list of approved conditions.
- **Approval**: Approval can be performed either by the entity (after conditions are met) or directly by a `PackageAdmin`.

### ConditionWitness

- **Purpose**: Used during the action request approval process to verify that a condition’s requirements have been satisfied.
- **Details**:
  - Includes the rule ID, condition configuration, policy ID, and entity ID.
  - Ensures that the correct config is used when validating an action request.

## Usage Flow

### PackageAdmin Creation:

Create a module named `access_init` and claim the PackageAdmin during package initialization:

```move
public struct ACCESS_INIT has drop {}

fun init(otw: ACCESS_INIT, ctx: &mut TxContext) {
    let admin = access::claim_package(otw, ctx);
    transfer::public_transfer(admin, tx_context::sender(ctx));
}
```

### Policy Creation:

`PackageAdmin` creates a Policy (or multiple) for that package which can allow "actions" that all Entities listed in that Policy will have access to

```move
let policy = access::create_empty_policy(&admin, ctx);
let rule_id = policy.add_empty_rule(&admin, ctx);
policy.add_action_to_rule<AFooOperation>(&admin, rule_id);
```

Where `AFooOperation` is an action witness struct defined somewhere in the package that is being granted access to:

```move
public struct AFooOperation has drop {}

public fun foo_operation(): ActionRequest {
    // ... do some stuff
    access::new_request(AFooOperation {}, ctx);
}
```

### Allowlisting an Entity:

Create an entity and add it to the policy:

```move
let entity = access::create_entity(ctx);
policy.allowlist_entity(&admin, object::borrow_id(&entity));
```

### Approving an Action Request:

The request can be approved by the entity that is allowed to perform the action by the policy:

```move
let request = foo_operation();
access::approve_request(request, &entity, &policy, rule_id);
```

Or by the `PackageAdmin` of the package:

```move
let request = foo_operation();
access::admin_approve_request(request, &admin);
```

### (Optional) Conditions:

It's also possible to add conditions to a rule which are required to be satisfied before the action can be approved. Each condition can optionally have a config struct that is going to be passed to the condition approval function during the approval process to allow for more complex logic. Here's an example of adding a condition that checks the current timestamp against a max timestamp set in the config:

```move
let config = TimestampConfig { max_timestamp_ms: 1712150400000 };
policy.add_condition_to_rule_with_config<CMaxTimestamp, TimestampConfig>(&admin, rule_id, config);
```

Where the `TimestampConfig` and `CMaxTimestamp` are defined in the condition module:

```move
public struct CMaxTimestamp has drop {}

public struct TimestampConfig has store, copy, drop {
    max_timestamp_ms: u64,
}

public fun approve_max_timestamp(
    request: &mut ActionRequest,
    witness: &ConditionWitness<CMaxTimestamp, TimestampConfig>,
    clock: &Clock,
) {
    assert!(
        clock.timestamp_ms() <= witness.config().max_timestamp_ms,
        EMaxTimestampExceeded
    );
    request.approve_condition(witness, CMaxTimestamp { });
}
```

To approve a request with a condition, the condition approval function must be called with the request and the condition witness:

```move
let request = foo_operation();

let cw = policy.get_condition_witness<CMaxTimestamp, AFooOperation>(&entity, rule_id);
approve_max_timestamp(&mut request, &cw, clock);

access::approve_request(request, &entity, &policy, rule_id);
```

### (Optional) Context:

It's also possible to add a context (`DynamicMap`) to an action request which can be used by condition approval functions to allow for more complex logic. Here's an example of adding a context to an action request to allow for a dynamic grace period for the `CMaxTimestamp` condition:

```move
public fun foo_operation(ctx: &mut TxContext): ActionRequest {
    // ... do some stuff

    let mut context = dynamic_map::new<String>(ctx);
    let grace_period_ms = 60 * 60 * 1000; // 1 hour
    dynamic_map::insert(&mut context, ascii::string(b"grace_period_ms"), grace_period_ms);
    access::new_request_with_context(AFooOperation {}, context)
}
```

This can then be used by the condition approval functions:

```move
public fun approve_max_timestamp_with_grace_period(
    request: &mut ActionRequest,
    witness: &ConditionWitness<CMaxTimestamp, TimestampConfig>,
    clock: &Clock,
) {
    let grace_period_ms = *request.context_value<u64>(ascii::string(b"grace_period_ms"));
    assert!(
        clock.timestamp_ms() <= witness.config().max_timestamp_ms + grace_period_ms,
        EMaxTimestampExceeded
    );
    request.approve_condition(witness, CMaxTimestamp { });
}
```
